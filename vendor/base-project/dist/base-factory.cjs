"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const a=(t,e,r)=>{const o=t[e];return o?typeof o=="function"?o():Promise.resolve(o):new Promise((y,n)=>{(typeof queueMicrotask=="function"?queueMicrotask:setTimeout)(n.bind(null,new Error("Unknown variable dynamic import: "+e+(e.split("/").length!==r?". Note that variables only represent file names one level deep.":""))))})};class c{static async loadPlugin(e){try{const r=await a(Object.assign({"../providers/name/index.ts":()=>Promise.resolve().then(()=>f)}),`../providers/${e}/index.ts`,4);if(r.register)console.log("[Plugin Loader] Register plugin:",e),r.register();else throw new Error(`[Plugin Loader] No register in ${e}`)}catch(r){throw console.error(`[Plugin Loader] Failed to load ${e}:`,r),r}}}class s{static factories=new Map;static register(e,r){this.factories.set(e,r)}static getFactory(e){const r=this.factories.get(e);if(!r)throw new Error(`[Provider Registry] No factory registered for '${e}'`);return r}static listProviders(){return Array.from(this.factories.keys())}}class l{static async getProvider(e){return await c.loadPlugin(e),s.getFactory(e).create()}}var i=(t=>(t.NAME="name",t))(i||{});class u{constructor(){}async start(){return console.log("NameProvider start"),!0}}class g{create(){return new u}}function d(){s.register(i.NAME,new g)}const f=Object.freeze(Object.defineProperty({__proto__:null,register:d},Symbol.toStringTag,{value:"Module"}));exports.EnumProvider=i;exports.ProviderFacade=l;
